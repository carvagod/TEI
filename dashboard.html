<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel de Usuario</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f9;
            margin: 0;
            padding: 20px;
            text-align: center;
        }
        header {
            background: #6200ea;
            color: #fff;
            padding: 1rem;
        }
        h1 {
            color: #6200ea;
        }
        footer {
            background: #333;
            color: #fff;
            padding: 1rem;
            position: relative; /* Ajustar para permitir espacio extra */
            width: 100%;
        }
        .table-container {
            overflow: auto; /* Scroll horizontal y vertical */
            max-height: 300px; /* Altura máxima para la tabla */
            max-width: 80%; /* Ancho máximo de la tabla */
            margin: 20px auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            text-align: center;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
        }
        th {
            background-color: #6200ea;
            color: #fff;
        }
        td {
            min-height: 40px; /* Reducir altura mínima de las celdas */
            font-size: 14px; /* Reducir tamaño de fuente */
        }
        .spacing {
            height: 100px; /* Espaciado adicional debajo de la tabla */
        }
    </style>
</head>
<body>
    <header>
        <h1>Bienvenido, <span id="userName"></span>!</h1>
    </header>
    <p>Aquí puedes gestionar tus horarios y tareas pendientes.</p>

    <!-- Título de la tabla -->
    <div class="table-title">Horarios Disponibles</div>
    
    <!-- Contenedor para la tabla -->
    <div id="tableContainer" class="table-container"></div>

    <!-- Espaciado adicional debajo de la tabla -->
    <div class="spacing"></div>
    <footer>
        <p>&copy; 2024 Gestión de Horarios. Todos los derechos reservados.</p>
    </footer>

    <script>
        const params = new URLSearchParams(window.location.search);
        const userName = params.get("name");
        const userId = params.get("userId");
        const horariosCsvUrl = "https://raw.githubusercontent.com/carvagod/TEI/refs/heads/main/horarios.csv"; // Enlace RAW del CSV de horarios

        if (userName) {
            document.getElementById("userName").textContent = decodeURIComponent(userName);

            // Función para crear la tabla vacía
            function crearTablaHorarios() {
                const table = document.createElement("table");

                // Crear encabezados (días de la semana)
                const headerRow = document.createElement("tr");
                const emptyCell = document.createElement("th");
                emptyCell.textContent = "Bloque";
                headerRow.appendChild(emptyCell);

                const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
                diasSemana.forEach(dia => {
                    const th = document.createElement("th");
                    th.textContent = dia;
                    headerRow.appendChild(th);
                });

                table.appendChild(headerRow);

                // Crear filas de bloques (1-12)
                for (let i = 1; i <= 12; i++) {
                    const row = document.createElement("tr");

                    // Primera celda: número del bloque
                    const blockCell = document.createElement("td");
                    blockCell.textContent = i;
                    row.appendChild(blockCell);

                    // Celdas vacías para cada día
                    for (let j = 0; j < diasSemana.length; j++) {
                        const cell = document.createElement("td");
                        row.appendChild(cell);
                    }

                    table.appendChild(row);
                }

                return table;
            }

            // Función para llenar la tabla con datos del CSV
            function llenarTablaHorarios(table, horarios) {
                const rows = table.querySelectorAll("tr");
                const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
        
                horarios.forEach(horario => {
                    const [id, ramo, seccion, ...horariosBloques] = horario.split(",");
                    if (id.trim() !== userId) return; // Verificar si el ID coincide con el usuario
        
                    for (let i = 0; i < horariosBloques.length; i += 2) {
                        const dia = horariosBloques[i]?.trim();
                        const bloque = parseInt(horariosBloques[i + 1]?.trim(), 10);
        
                        if (dia && bloque && diasSemana.includes(dia)) {
                            const diaIndex = diasSemana.indexOf(dia) + 1; // +1 porque la primera columna es el número de bloque
                            const cell = rows[bloque].children[diaIndex];
        
                            const contenido = `${ramo} (Sección ${seccion})`;
                            if (cell.textContent.trim()) {
                                cell.textContent += ` // ${contenido}`;
                            } else {
                                cell.textContent = contenido;
                            }
                        }
                    }
                });
            }

            // Cargar datos del CSV y generar la tabla
            fetch(horariosCsvUrl)
                .then(response => {
                    if (!response.ok) throw new Error("Error al cargar los datos del CSV.");
                    return response.text();
                })
                .then(data => {
                    const horarios = data.split("\n").slice(1).filter(row => row); // Omitir encabezados y filas vacías

                    const tableContainer = document.getElementById("tableContainer");
                    const table = crearTablaHorarios();
                    llenarTablaHorarios(table, horarios);
                    tableContainer.appendChild(table);
                })
                .catch(error => {
                    console.error(error);
                    document.body.innerHTML += "<p>Error al cargar los horarios. Intenta más tarde.</p>";
                });
        } else {
            document.body.innerHTML = "<h1>Acceso denegado. Inicia sesión primero.</h1>";
        }
    </script>

    <script>
        // Función para analizar y generar combinaciones sin conflictos
        function generarCombinacionesSinTopes(horarios) {
            const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
    
            // Agrupar horarios por ramo y secciones
            const ramos = {};
            horarios.forEach(horario => {
                const [id, ramo, seccion, ...horariosBloques] = horario.split(",");
                if (!ramos[ramo]) ramos[ramo] = [];
                ramos[ramo].push({
                    seccion: seccion.trim(),
                    bloques: horariosBloques.reduce((acc, _, i) => {
                        if (i % 2 === 0) {
                            const dia = horariosBloques[i]?.trim();
                            const bloque = parseInt(horariosBloques[i + 1]?.trim(), 10);
                            if (dia && bloque) acc.push({ dia, bloque });
                        }
                        return acc;
                    }, [])
                });
            });
    
            // Generar combinaciones sin conflictos
            const combinaciones = [];
            function backtrack(combinacionActual, ramosRestantes) {
                if (ramosRestantes.length === 0) {
                    combinaciones.push([...combinacionActual]);
                    return;
                }
    
                const [ramoActual, ...restoRamos] = ramosRestantes;
                for (const seccion of ramos[ramoActual]) {
                    // Verificar si hay conflictos con la combinación actual
                    const hayConflicto = combinacionActual.some(combinacion => {
                        return combinacion.bloques.some(bloqueA =>
                            seccion.bloques.some(bloqueB => bloqueA.dia === bloqueB.dia && bloqueA.bloque === bloqueB.bloque)
                        );
                    });
    
                    if (!hayConflicto) {
                        combinacionActual.push({ ramo: ramoActual, ...seccion });
                        backtrack(combinacionActual, restoRamos);
                        combinacionActual.pop();
                    }
                }
            }
    
            backtrack([], Object.keys(ramos));
            return combinaciones;
        }
    
        // Crear una tabla para mostrar una combinación
        function crearTablaCombinacion(combinacion, indice) {
            const tableContainer = document.createElement("div");
            tableContainer.className = "table-container";
    
            const tableTitle = document.createElement("div");
            tableTitle.className = "table-title";
            tableTitle.textContent = `Posible combinación ${indice}`;
    
            const table = document.createElement("table");
            const headerRow = document.createElement("tr");
            const emptyCell = document.createElement("th");
            emptyCell.textContent = "Bloque";
            headerRow.appendChild(emptyCell);
    
            const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
            diasSemana.forEach(dia => {
                const th = document.createElement("th");
                th.textContent = dia;
                headerRow.appendChild(th);
            });
    
            table.appendChild(headerRow);
    
            for (let i = 1; i <= 12; i++) {
                const row = document.createElement("tr");
    
                const blockCell = document.createElement("td");
                blockCell.textContent = i;
                row.appendChild(blockCell);
    
                for (let j = 0; j < diasSemana.length; j++) {
                    const cell = document.createElement("td");
                    row.appendChild(cell);
                }
    
                table.appendChild(row);
            }
    
            // Llenar la tabla con la combinación
            const rows = table.querySelectorAll("tr");
            combinacion.forEach(({ ramo, seccion, bloques }) => {
                bloques.forEach(({ dia, bloque }) => {
                    const diaIndex = diasSemana.indexOf(dia) + 1; // +1 porque la primera columna es el número de bloque
                    const cell = rows[bloque].children[diaIndex];
                    cell.textContent = `${ramo} (Sección ${seccion})`;
                });
            });
    
            tableContainer.appendChild(tableTitle);
            tableContainer.appendChild(table);
            return tableContainer;
        }
    
        // Función para generar y mostrar todas las combinaciones
        function mostrarCombinaciones(horarios) {
            const combinaciones = generarCombinacionesSinTopes(horarios);
    
            combinaciones.forEach((combinacion, index) => {
                const tableContainer = crearTablaCombinacion(combinacion, index + 1);
                document.body.appendChild(tableContainer);
            });
    
            if (combinaciones.length === 0) {
                const noCombinationsMessage = document.createElement("p");
                noCombinationsMessage.textContent = "No hay combinaciones posibles sin conflictos de horarios.";
                document.body.appendChild(noCombinationsMessage);
            }
        }
    
        // Cargar y procesar los horarios
        fetch(horariosCsvUrl)
            .then(response => {
                if (!response.ok) throw new Error("Error al cargar los datos del CSV.");
                return response.text();
            })
            .then(data => {
                const horarios = data.split("\n").slice(1).filter(row => row); // Omitir encabezados y filas vacías
                mostrarCombinaciones(horarios);
            })
            .catch(error => {
                console.error(error);
                document.body.innerHTML += "<p>Error al procesar las combinaciones. Intenta más tarde.</p>";
            });
    </script>

    <script>
    // Función para analizar y generar combinaciones sin conflictos
    function generarCombinacionesSinTopes(horarios) {
        const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];

        // Agrupar horarios por ramo y secciones
        const ramos = {};
        horarios.forEach(horario => {
            const [id, ramo, seccion, ...horariosBloques] = horario.split(",");
            if (!ramos[ramo]) ramos[ramo] = [];
            ramos[ramo].push({
                seccion: seccion.trim(),
                bloques: horariosBloques.reduce((acc, _, i) => {
                    if (i % 2 === 0) {
                        const dia = horariosBloques[i]?.trim();
                        const bloque = parseInt(horariosBloques[i + 1]?.trim(), 10);
                        if (dia && bloque) acc.push({ dia, bloque });
                    }
                    return acc;
                }, [])
            });
        });

        // Generar combinaciones sin conflictos
        const combinaciones = [];
        function backtrack(combinacionActual, ramosRestantes) {
            if (ramosRestantes.length === 0) {
                combinaciones.push([...combinacionActual]);
                return;
            }

            const [ramoActual, ...restoRamos] = ramosRestantes;
            for (const seccion of ramos[ramoActual]) {
                // Verificar si hay conflictos con la combinación actual
                const hayConflicto = combinacionActual.some(combinacion => {
                    return combinacion.bloques.some(bloqueA =>
                        seccion.bloques.some(bloqueB => bloqueA.dia === bloqueB.dia && bloqueA.bloque === bloqueB.bloque)
                    );
                });

                if (!hayConflicto) {
                    combinacionActual.push({ ramo: ramoActual, ...seccion });
                    backtrack(combinacionActual, restoRamos);
                    combinacionActual.pop();
                }
            }
        }

        backtrack([], Object.keys(ramos));
        return combinaciones;
    }

    // Crear una tabla para mostrar una combinación
    function crearTablaCombinacion(combinacion, indice) {
        const tableContainer = document.createElement("div");
        tableContainer.className = "table-container";
        tableContainer.dataset.index = indice; // Agregar índice para identificar la tabla

        const tableTitle = document.createElement("div");
        tableTitle.className = "table-title";
        tableTitle.textContent = `Posible combinación ${indice}`;

        const table = document.createElement("table");
        const headerRow = document.createElement("tr");
        const emptyCell = document.createElement("th");
        emptyCell.textContent = "Bloque";
        headerRow.appendChild(emptyCell);

        const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
        diasSemana.forEach(dia => {
            const th = document.createElement("th");
            th.textContent = dia;
            headerRow.appendChild(th);
        });

        table.appendChild(headerRow);

        for (let i = 1; i <= 12; i++) {
            const row = document.createElement("tr");

            const blockCell = document.createElement("td");
            blockCell.textContent = i;
            row.appendChild(blockCell);

            for (let j = 0; j < diasSemana.length; j++) {
                const cell = document.createElement("td");
                row.appendChild(cell);
            }

            table.appendChild(row);
        }

        // Llenar la tabla con la combinación
        const rows = table.querySelectorAll("tr");
        combinacion.forEach(({ ramo, seccion, bloques }) => {
            bloques.forEach(({ dia, bloque }) => {
                const diaIndex = diasSemana.indexOf(dia) + 1; // +1 porque la primera columna es el número de bloque
                const cell = rows[bloque].children[diaIndex];
                cell.textContent = `${ramo} (Sección ${seccion})`;
            });
        });

        tableContainer.appendChild(tableTitle);
        tableContainer.appendChild(table);
        return tableContainer;
    }

    // Calcular ventanas de una tabla
    function calcularVentanas(table) {
        const rows = table.querySelectorAll("tr");
        const diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
        let totalVentanas = 0;

        for (let diaIndex = 1; diaIndex <= diasSemana.length; diaIndex++) {
            let bloquesDia = [];
            for (let bloque = 1; bloque <= 12; bloque++) {
                const cell = rows[bloque].children[diaIndex];
                if (cell.textContent.trim()) {
                    bloquesDia.push(bloque);
                }
            }

            // Calcular ventanas en este día
            for (let i = 0; i < bloquesDia.length - 1; i++) {
                const ventana = bloquesDia[i + 1] - bloquesDia[i] - 1;
                totalVentanas += ventana > 0 ? ventana : 0;
            }
        }

        return totalVentanas;
    }

    // Función para mostrar combinaciones y determinar la mejor
    function mostrarCombinaciones(horarios) {
        const combinaciones = generarCombinacionesSinTopes(horarios);
        const combinacionTablas = [];

        combinaciones.forEach((combinacion, index) => {
            const tableContainer = crearTablaCombinacion(combinacion, index + 1);
            document.body.appendChild(tableContainer);
            combinacionTablas.push({ table: tableContainer.querySelector("table"), container: tableContainer });
        });

        if (combinacionTablas.length === 0) {
            const noCombinationsMessage = document.createElement("p");
            noCombinationsMessage.textContent = "No hay combinaciones posibles sin conflictos de horarios.";
            document.body.appendChild(noCombinationsMessage);
            return;
        }

        // Calcular ventanas y determinar la mejor combinación
        let mejorIndice = 0;
        let menorVentanas = Infinity;

        combinacionTablas.forEach((tabla, index) => {
            const ventanas = calcularVentanas(tabla.table);
            if (ventanas < menorVentanas) {
                menorVentanas = ventanas;
                mejorIndice = index;
            }
        });

        // Marcar la mejor combinación
        const mejorTabla = combinacionTablas[mejorIndice].container;
        const titulo = mejorTabla.querySelector(".table-title");
        titulo.textContent += ": Mejor combinación";
    }

    // Cargar y procesar los horarios
    fetch(horariosCsvUrl)
        .then(response => {
            if (!response.ok) throw new Error("Error al cargar los datos del CSV.");
            return response.text();
        })
        .then(data => {
            const horarios = data.split("\n").slice(1).filter(row => row); // Omitir encabezados y filas vacías
            mostrarCombinaciones(horarios);
        })
        .catch(error => {
            console.error(error);
            document.body.innerHTML += "<p>Error al procesar las combinaciones. Intenta más tarde.</p>";
        });
    </script>

</body>
</html>
